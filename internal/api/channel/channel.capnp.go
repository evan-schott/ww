// Code generated by capnpc-go. DO NOT EDIT.

package channel

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	stream "capnproto.org/go/capnp/v3/std/capnp/stream"
	context "context"
	fmt "fmt"
)

type Closer capnp.Client

// Closer_TypeID is the unique identifier for the type Closer.
const Closer_TypeID = 0xfad0e4b80d3779c3

func (c Closer) Close(ctx context.Context, params func(Closer_close_Params) error) (Closer_close_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Closer_close_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Closer_close_Results_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Closer) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Closer) AddRef() Closer {
	return Closer(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Closer) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Closer) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Closer) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Closer) DecodeFromPtr(p capnp.Ptr) Closer {
	return Closer(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Closer) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Closer) IsSame(other Closer) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Closer) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Closer) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A Closer_Server is a Closer with a local implementation.
type Closer_Server interface {
	Close(context.Context, Closer_close) error
}

// Closer_NewServer creates a new Server from an implementation of Closer_Server.
func Closer_NewServer(s Closer_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Closer_Methods(nil, s), s, c)
}

// Closer_ServerToClient creates a new Client from an implementation of Closer_Server.
// The caller is responsible for calling Release on the returned Client.
func Closer_ServerToClient(s Closer_Server) Closer {
	return Closer(capnp.NewClient(Closer_NewServer(s)))
}

// Closer_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Closer_Methods(methods []server.Method, s Closer_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Close(ctx, Closer_close{call})
		},
	})

	return methods
}

// Closer_close holds the state for a server call to Closer.close.
// See server.Call for documentation.
type Closer_close struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Closer_close) Args() Closer_close_Params {
	return Closer_close_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Closer_close) AllocResults() (Closer_close_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Closer_close_Results(r), err
}

// Closer_List is a list of Closer.
type Closer_List = capnp.CapList[Closer]

// NewCloser creates a new list of Closer.
func NewCloser_List(s *capnp.Segment, sz int32) (Closer_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Closer](l), err
}

type Closer_close_Params capnp.Struct

// Closer_close_Params_TypeID is the unique identifier for the type Closer_close_Params.
const Closer_close_Params_TypeID = 0xfd07d8a1cc36583c

func NewCloser_close_Params(s *capnp.Segment) (Closer_close_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Closer_close_Params(st), err
}

func NewRootCloser_close_Params(s *capnp.Segment) (Closer_close_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Closer_close_Params(st), err
}

func ReadRootCloser_close_Params(msg *capnp.Message) (Closer_close_Params, error) {
	root, err := msg.Root()
	return Closer_close_Params(root.Struct()), err
}

func (s Closer_close_Params) String() string {
	str, _ := text.Marshal(0xfd07d8a1cc36583c, capnp.Struct(s))
	return str
}

func (s Closer_close_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Closer_close_Params) DecodeFromPtr(p capnp.Ptr) Closer_close_Params {
	return Closer_close_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Closer_close_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Closer_close_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Closer_close_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Closer_close_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Closer_close_Params_List is a list of Closer_close_Params.
type Closer_close_Params_List = capnp.StructList[Closer_close_Params]

// NewCloser_close_Params creates a new list of Closer_close_Params.
func NewCloser_close_Params_List(s *capnp.Segment, sz int32) (Closer_close_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Closer_close_Params](l), err
}

// Closer_close_Params_Future is a wrapper for a Closer_close_Params promised by a client call.
type Closer_close_Params_Future struct{ *capnp.Future }

func (f Closer_close_Params_Future) Struct() (Closer_close_Params, error) {
	p, err := f.Future.Ptr()
	return Closer_close_Params(p.Struct()), err
}

type Closer_close_Results capnp.Struct

// Closer_close_Results_TypeID is the unique identifier for the type Closer_close_Results.
const Closer_close_Results_TypeID = 0xcbee5caf8b7af4ea

func NewCloser_close_Results(s *capnp.Segment) (Closer_close_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Closer_close_Results(st), err
}

func NewRootCloser_close_Results(s *capnp.Segment) (Closer_close_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Closer_close_Results(st), err
}

func ReadRootCloser_close_Results(msg *capnp.Message) (Closer_close_Results, error) {
	root, err := msg.Root()
	return Closer_close_Results(root.Struct()), err
}

func (s Closer_close_Results) String() string {
	str, _ := text.Marshal(0xcbee5caf8b7af4ea, capnp.Struct(s))
	return str
}

func (s Closer_close_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Closer_close_Results) DecodeFromPtr(p capnp.Ptr) Closer_close_Results {
	return Closer_close_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Closer_close_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Closer_close_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Closer_close_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Closer_close_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Closer_close_Results_List is a list of Closer_close_Results.
type Closer_close_Results_List = capnp.StructList[Closer_close_Results]

// NewCloser_close_Results creates a new list of Closer_close_Results.
func NewCloser_close_Results_List(s *capnp.Segment, sz int32) (Closer_close_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Closer_close_Results](l), err
}

// Closer_close_Results_Future is a wrapper for a Closer_close_Results promised by a client call.
type Closer_close_Results_Future struct{ *capnp.Future }

func (f Closer_close_Results_Future) Struct() (Closer_close_Results, error) {
	p, err := f.Future.Ptr()
	return Closer_close_Results(p.Struct()), err
}

type Sender capnp.Client

// Sender_TypeID is the unique identifier for the type Sender.
const Sender_TypeID = 0xe8bbed1438ea16ee

func (c Sender) Send(ctx context.Context, params func(Sender_send_Params) error) (stream.StreamResult_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Sender_send_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return stream.StreamResult_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Sender) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Sender) AddRef() Sender {
	return Sender(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Sender) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Sender) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Sender) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Sender) DecodeFromPtr(p capnp.Ptr) Sender {
	return Sender(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Sender) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Sender) IsSame(other Sender) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Sender) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Sender) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A Sender_Server is a Sender with a local implementation.
type Sender_Server interface {
	Send(context.Context, Sender_send) error
}

// Sender_NewServer creates a new Server from an implementation of Sender_Server.
func Sender_NewServer(s Sender_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Sender_Methods(nil, s), s, c)
}

// Sender_ServerToClient creates a new Client from an implementation of Sender_Server.
// The caller is responsible for calling Release on the returned Client.
func Sender_ServerToClient(s Sender_Server) Sender {
	return Sender(capnp.NewClient(Sender_NewServer(s)))
}

// Sender_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Sender_Methods(methods []server.Method, s Sender_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Send(ctx, Sender_send{call})
		},
	})

	return methods
}

// Sender_send holds the state for a server call to Sender.send.
// See server.Call for documentation.
type Sender_send struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Sender_send) Args() Sender_send_Params {
	return Sender_send_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Sender_send) AllocResults() (stream.StreamResult, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return stream.StreamResult(r), err
}

// Sender_List is a list of Sender.
type Sender_List = capnp.CapList[Sender]

// NewSender creates a new list of Sender.
func NewSender_List(s *capnp.Segment, sz int32) (Sender_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Sender](l), err
}

type Sender_send_Params capnp.Struct

// Sender_send_Params_TypeID is the unique identifier for the type Sender_send_Params.
const Sender_send_Params_TypeID = 0x8166bc9c3ded78ca

func NewSender_send_Params(s *capnp.Segment) (Sender_send_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Sender_send_Params(st), err
}

func NewRootSender_send_Params(s *capnp.Segment) (Sender_send_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Sender_send_Params(st), err
}

func ReadRootSender_send_Params(msg *capnp.Message) (Sender_send_Params, error) {
	root, err := msg.Root()
	return Sender_send_Params(root.Struct()), err
}

func (s Sender_send_Params) String() string {
	str, _ := text.Marshal(0x8166bc9c3ded78ca, capnp.Struct(s))
	return str
}

func (s Sender_send_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Sender_send_Params) DecodeFromPtr(p capnp.Ptr) Sender_send_Params {
	return Sender_send_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Sender_send_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Sender_send_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Sender_send_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Sender_send_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Sender_send_Params) Value() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(0)
}

func (s Sender_send_Params) HasValue() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Sender_send_Params) SetValue(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(0, v)
}

// Sender_send_Params_List is a list of Sender_send_Params.
type Sender_send_Params_List = capnp.StructList[Sender_send_Params]

// NewSender_send_Params creates a new list of Sender_send_Params.
func NewSender_send_Params_List(s *capnp.Segment, sz int32) (Sender_send_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Sender_send_Params](l), err
}

// Sender_send_Params_Future is a wrapper for a Sender_send_Params promised by a client call.
type Sender_send_Params_Future struct{ *capnp.Future }

func (f Sender_send_Params_Future) Struct() (Sender_send_Params, error) {
	p, err := f.Future.Ptr()
	return Sender_send_Params(p.Struct()), err
}
func (p Sender_send_Params_Future) Value() *capnp.Future {
	return p.Future.Field(0, nil)
}

type Peeker capnp.Client

// Peeker_TypeID is the unique identifier for the type Peeker.
const Peeker_TypeID = 0xe95c7f9f41bf520a

func (c Peeker) Peek(ctx context.Context, params func(Peeker_peek_Params) error) (Peeker_peek_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe95c7f9f41bf520a,
			MethodID:      0,
			InterfaceName: "channel.capnp:Peeker",
			MethodName:    "peek",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Peeker_peek_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Peeker_peek_Results_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Peeker) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Peeker) AddRef() Peeker {
	return Peeker(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Peeker) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Peeker) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Peeker) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Peeker) DecodeFromPtr(p capnp.Ptr) Peeker {
	return Peeker(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Peeker) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Peeker) IsSame(other Peeker) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Peeker) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Peeker) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A Peeker_Server is a Peeker with a local implementation.
type Peeker_Server interface {
	Peek(context.Context, Peeker_peek) error
}

// Peeker_NewServer creates a new Server from an implementation of Peeker_Server.
func Peeker_NewServer(s Peeker_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Peeker_Methods(nil, s), s, c)
}

// Peeker_ServerToClient creates a new Client from an implementation of Peeker_Server.
// The caller is responsible for calling Release on the returned Client.
func Peeker_ServerToClient(s Peeker_Server) Peeker {
	return Peeker(capnp.NewClient(Peeker_NewServer(s)))
}

// Peeker_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Peeker_Methods(methods []server.Method, s Peeker_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe95c7f9f41bf520a,
			MethodID:      0,
			InterfaceName: "channel.capnp:Peeker",
			MethodName:    "peek",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Peek(ctx, Peeker_peek{call})
		},
	})

	return methods
}

// Peeker_peek holds the state for a server call to Peeker.peek.
// See server.Call for documentation.
type Peeker_peek struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Peeker_peek) Args() Peeker_peek_Params {
	return Peeker_peek_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Peeker_peek) AllocResults() (Peeker_peek_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Peeker_peek_Results(r), err
}

// Peeker_List is a list of Peeker.
type Peeker_List = capnp.CapList[Peeker]

// NewPeeker creates a new list of Peeker.
func NewPeeker_List(s *capnp.Segment, sz int32) (Peeker_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Peeker](l), err
}

type Peeker_peek_Params capnp.Struct

// Peeker_peek_Params_TypeID is the unique identifier for the type Peeker_peek_Params.
const Peeker_peek_Params_TypeID = 0xaf261efa7a102288

func NewPeeker_peek_Params(s *capnp.Segment) (Peeker_peek_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Peeker_peek_Params(st), err
}

func NewRootPeeker_peek_Params(s *capnp.Segment) (Peeker_peek_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Peeker_peek_Params(st), err
}

func ReadRootPeeker_peek_Params(msg *capnp.Message) (Peeker_peek_Params, error) {
	root, err := msg.Root()
	return Peeker_peek_Params(root.Struct()), err
}

func (s Peeker_peek_Params) String() string {
	str, _ := text.Marshal(0xaf261efa7a102288, capnp.Struct(s))
	return str
}

func (s Peeker_peek_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Peeker_peek_Params) DecodeFromPtr(p capnp.Ptr) Peeker_peek_Params {
	return Peeker_peek_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Peeker_peek_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Peeker_peek_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Peeker_peek_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Peeker_peek_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Peeker_peek_Params_List is a list of Peeker_peek_Params.
type Peeker_peek_Params_List = capnp.StructList[Peeker_peek_Params]

// NewPeeker_peek_Params creates a new list of Peeker_peek_Params.
func NewPeeker_peek_Params_List(s *capnp.Segment, sz int32) (Peeker_peek_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Peeker_peek_Params](l), err
}

// Peeker_peek_Params_Future is a wrapper for a Peeker_peek_Params promised by a client call.
type Peeker_peek_Params_Future struct{ *capnp.Future }

func (f Peeker_peek_Params_Future) Struct() (Peeker_peek_Params, error) {
	p, err := f.Future.Ptr()
	return Peeker_peek_Params(p.Struct()), err
}

type Peeker_peek_Results capnp.Struct

// Peeker_peek_Results_TypeID is the unique identifier for the type Peeker_peek_Results.
const Peeker_peek_Results_TypeID = 0xb42eee8bed32bea0

func NewPeeker_peek_Results(s *capnp.Segment) (Peeker_peek_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Peeker_peek_Results(st), err
}

func NewRootPeeker_peek_Results(s *capnp.Segment) (Peeker_peek_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Peeker_peek_Results(st), err
}

func ReadRootPeeker_peek_Results(msg *capnp.Message) (Peeker_peek_Results, error) {
	root, err := msg.Root()
	return Peeker_peek_Results(root.Struct()), err
}

func (s Peeker_peek_Results) String() string {
	str, _ := text.Marshal(0xb42eee8bed32bea0, capnp.Struct(s))
	return str
}

func (s Peeker_peek_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Peeker_peek_Results) DecodeFromPtr(p capnp.Ptr) Peeker_peek_Results {
	return Peeker_peek_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Peeker_peek_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Peeker_peek_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Peeker_peek_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Peeker_peek_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Peeker_peek_Results) Value() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(0)
}

func (s Peeker_peek_Results) HasValue() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Peeker_peek_Results) SetValue(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(0, v)
}

// Peeker_peek_Results_List is a list of Peeker_peek_Results.
type Peeker_peek_Results_List = capnp.StructList[Peeker_peek_Results]

// NewPeeker_peek_Results creates a new list of Peeker_peek_Results.
func NewPeeker_peek_Results_List(s *capnp.Segment, sz int32) (Peeker_peek_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Peeker_peek_Results](l), err
}

// Peeker_peek_Results_Future is a wrapper for a Peeker_peek_Results promised by a client call.
type Peeker_peek_Results_Future struct{ *capnp.Future }

func (f Peeker_peek_Results_Future) Struct() (Peeker_peek_Results, error) {
	p, err := f.Future.Ptr()
	return Peeker_peek_Results(p.Struct()), err
}
func (p Peeker_peek_Results_Future) Value() *capnp.Future {
	return p.Future.Field(0, nil)
}

type Recver capnp.Client

// Recver_TypeID is the unique identifier for the type Recver.
const Recver_TypeID = 0xdf05a90d671c0c07

func (c Recver) Recv(ctx context.Context, params func(Recver_recv_Params) error) (Recver_recv_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Recver_recv_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Recver_recv_Results_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Recver) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Recver) AddRef() Recver {
	return Recver(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Recver) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Recver) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Recver) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Recver) DecodeFromPtr(p capnp.Ptr) Recver {
	return Recver(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Recver) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Recver) IsSame(other Recver) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Recver) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Recver) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A Recver_Server is a Recver with a local implementation.
type Recver_Server interface {
	Recv(context.Context, Recver_recv) error
}

// Recver_NewServer creates a new Server from an implementation of Recver_Server.
func Recver_NewServer(s Recver_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Recver_Methods(nil, s), s, c)
}

// Recver_ServerToClient creates a new Client from an implementation of Recver_Server.
// The caller is responsible for calling Release on the returned Client.
func Recver_ServerToClient(s Recver_Server) Recver {
	return Recver(capnp.NewClient(Recver_NewServer(s)))
}

// Recver_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Recver_Methods(methods []server.Method, s Recver_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Recv(ctx, Recver_recv{call})
		},
	})

	return methods
}

// Recver_recv holds the state for a server call to Recver.recv.
// See server.Call for documentation.
type Recver_recv struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Recver_recv) Args() Recver_recv_Params {
	return Recver_recv_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Recver_recv) AllocResults() (Recver_recv_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Recver_recv_Results(r), err
}

// Recver_List is a list of Recver.
type Recver_List = capnp.CapList[Recver]

// NewRecver creates a new list of Recver.
func NewRecver_List(s *capnp.Segment, sz int32) (Recver_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Recver](l), err
}

type Recver_recv_Params capnp.Struct

// Recver_recv_Params_TypeID is the unique identifier for the type Recver_recv_Params.
const Recver_recv_Params_TypeID = 0xdd377ddc0d2426ea

func NewRecver_recv_Params(s *capnp.Segment) (Recver_recv_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Recver_recv_Params(st), err
}

func NewRootRecver_recv_Params(s *capnp.Segment) (Recver_recv_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Recver_recv_Params(st), err
}

func ReadRootRecver_recv_Params(msg *capnp.Message) (Recver_recv_Params, error) {
	root, err := msg.Root()
	return Recver_recv_Params(root.Struct()), err
}

func (s Recver_recv_Params) String() string {
	str, _ := text.Marshal(0xdd377ddc0d2426ea, capnp.Struct(s))
	return str
}

func (s Recver_recv_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Recver_recv_Params) DecodeFromPtr(p capnp.Ptr) Recver_recv_Params {
	return Recver_recv_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Recver_recv_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Recver_recv_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Recver_recv_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Recver_recv_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Recver_recv_Params_List is a list of Recver_recv_Params.
type Recver_recv_Params_List = capnp.StructList[Recver_recv_Params]

// NewRecver_recv_Params creates a new list of Recver_recv_Params.
func NewRecver_recv_Params_List(s *capnp.Segment, sz int32) (Recver_recv_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Recver_recv_Params](l), err
}

// Recver_recv_Params_Future is a wrapper for a Recver_recv_Params promised by a client call.
type Recver_recv_Params_Future struct{ *capnp.Future }

func (f Recver_recv_Params_Future) Struct() (Recver_recv_Params, error) {
	p, err := f.Future.Ptr()
	return Recver_recv_Params(p.Struct()), err
}

type Recver_recv_Results capnp.Struct

// Recver_recv_Results_TypeID is the unique identifier for the type Recver_recv_Results.
const Recver_recv_Results_TypeID = 0xb0e88f4d0a3a1694

func NewRecver_recv_Results(s *capnp.Segment) (Recver_recv_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Recver_recv_Results(st), err
}

func NewRootRecver_recv_Results(s *capnp.Segment) (Recver_recv_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Recver_recv_Results(st), err
}

func ReadRootRecver_recv_Results(msg *capnp.Message) (Recver_recv_Results, error) {
	root, err := msg.Root()
	return Recver_recv_Results(root.Struct()), err
}

func (s Recver_recv_Results) String() string {
	str, _ := text.Marshal(0xb0e88f4d0a3a1694, capnp.Struct(s))
	return str
}

func (s Recver_recv_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Recver_recv_Results) DecodeFromPtr(p capnp.Ptr) Recver_recv_Results {
	return Recver_recv_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Recver_recv_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Recver_recv_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Recver_recv_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Recver_recv_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Recver_recv_Results) Value() (capnp.Ptr, error) {
	return capnp.Struct(s).Ptr(0)
}

func (s Recver_recv_Results) HasValue() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Recver_recv_Results) SetValue(v capnp.Ptr) error {
	return capnp.Struct(s).SetPtr(0, v)
}

// Recver_recv_Results_List is a list of Recver_recv_Results.
type Recver_recv_Results_List = capnp.StructList[Recver_recv_Results]

// NewRecver_recv_Results creates a new list of Recver_recv_Results.
func NewRecver_recv_Results_List(s *capnp.Segment, sz int32) (Recver_recv_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Recver_recv_Results](l), err
}

// Recver_recv_Results_Future is a wrapper for a Recver_recv_Results promised by a client call.
type Recver_recv_Results_Future struct{ *capnp.Future }

func (f Recver_recv_Results_Future) Struct() (Recver_recv_Results, error) {
	p, err := f.Future.Ptr()
	return Recver_recv_Results(p.Struct()), err
}
func (p Recver_recv_Results_Future) Value() *capnp.Future {
	return p.Future.Field(0, nil)
}

type SendCloser capnp.Client

// SendCloser_TypeID is the unique identifier for the type SendCloser.
const SendCloser_TypeID = 0xe9a7d19a7d14e94e

func (c SendCloser) Send(ctx context.Context, params func(Sender_send_Params) error) (stream.StreamResult_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Sender_send_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return stream.StreamResult_Future{Future: ans.Future()}, release
}
func (c SendCloser) Close(ctx context.Context, params func(Closer_close_Params) error) (Closer_close_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Closer_close_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Closer_close_Results_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c SendCloser) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c SendCloser) AddRef() SendCloser {
	return SendCloser(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c SendCloser) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c SendCloser) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c SendCloser) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (SendCloser) DecodeFromPtr(p capnp.Ptr) SendCloser {
	return SendCloser(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c SendCloser) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c SendCloser) IsSame(other SendCloser) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c SendCloser) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c SendCloser) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A SendCloser_Server is a SendCloser with a local implementation.
type SendCloser_Server interface {
	Send(context.Context, Sender_send) error

	Close(context.Context, Closer_close) error
}

// SendCloser_NewServer creates a new Server from an implementation of SendCloser_Server.
func SendCloser_NewServer(s SendCloser_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(SendCloser_Methods(nil, s), s, c)
}

// SendCloser_ServerToClient creates a new Client from an implementation of SendCloser_Server.
// The caller is responsible for calling Release on the returned Client.
func SendCloser_ServerToClient(s SendCloser_Server) SendCloser {
	return SendCloser(capnp.NewClient(SendCloser_NewServer(s)))
}

// SendCloser_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func SendCloser_Methods(methods []server.Method, s SendCloser_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 2)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Send(ctx, Sender_send{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Close(ctx, Closer_close{call})
		},
	})

	return methods
}

// SendCloser_List is a list of SendCloser.
type SendCloser_List = capnp.CapList[SendCloser]

// NewSendCloser creates a new list of SendCloser.
func NewSendCloser_List(s *capnp.Segment, sz int32) (SendCloser_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[SendCloser](l), err
}

type PeekRecver capnp.Client

// PeekRecver_TypeID is the unique identifier for the type PeekRecver.
const PeekRecver_TypeID = 0x9a4abff8ccb5093c

func (c PeekRecver) Peek(ctx context.Context, params func(Peeker_peek_Params) error) (Peeker_peek_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe95c7f9f41bf520a,
			MethodID:      0,
			InterfaceName: "channel.capnp:Peeker",
			MethodName:    "peek",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Peeker_peek_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Peeker_peek_Results_Future{Future: ans.Future()}, release
}
func (c PeekRecver) Recv(ctx context.Context, params func(Recver_recv_Params) error) (Recver_recv_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Recver_recv_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Recver_recv_Results_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c PeekRecver) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c PeekRecver) AddRef() PeekRecver {
	return PeekRecver(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c PeekRecver) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c PeekRecver) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c PeekRecver) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (PeekRecver) DecodeFromPtr(p capnp.Ptr) PeekRecver {
	return PeekRecver(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c PeekRecver) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c PeekRecver) IsSame(other PeekRecver) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c PeekRecver) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c PeekRecver) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A PeekRecver_Server is a PeekRecver with a local implementation.
type PeekRecver_Server interface {
	Peek(context.Context, Peeker_peek) error

	Recv(context.Context, Recver_recv) error
}

// PeekRecver_NewServer creates a new Server from an implementation of PeekRecver_Server.
func PeekRecver_NewServer(s PeekRecver_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(PeekRecver_Methods(nil, s), s, c)
}

// PeekRecver_ServerToClient creates a new Client from an implementation of PeekRecver_Server.
// The caller is responsible for calling Release on the returned Client.
func PeekRecver_ServerToClient(s PeekRecver_Server) PeekRecver {
	return PeekRecver(capnp.NewClient(PeekRecver_NewServer(s)))
}

// PeekRecver_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func PeekRecver_Methods(methods []server.Method, s PeekRecver_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 2)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe95c7f9f41bf520a,
			MethodID:      0,
			InterfaceName: "channel.capnp:Peeker",
			MethodName:    "peek",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Peek(ctx, Peeker_peek{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Recv(ctx, Recver_recv{call})
		},
	})

	return methods
}

// PeekRecver_List is a list of PeekRecver.
type PeekRecver_List = capnp.CapList[PeekRecver]

// NewPeekRecver creates a new list of PeekRecver.
func NewPeekRecver_List(s *capnp.Segment, sz int32) (PeekRecver_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[PeekRecver](l), err
}

type Chan capnp.Client

// Chan_TypeID is the unique identifier for the type Chan.
const Chan_TypeID = 0x95c89fe7d966f751

func (c Chan) Send(ctx context.Context, params func(Sender_send_Params) error) (stream.StreamResult_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Sender_send_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return stream.StreamResult_Future{Future: ans.Future()}, release
}
func (c Chan) Close(ctx context.Context, params func(Closer_close_Params) error) (Closer_close_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Closer_close_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Closer_close_Results_Future{Future: ans.Future()}, release
}
func (c Chan) Recv(ctx context.Context, params func(Recver_recv_Params) error) (Recver_recv_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Recver_recv_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Recver_recv_Results_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Chan) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Chan) AddRef() Chan {
	return Chan(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Chan) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Chan) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Chan) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Chan) DecodeFromPtr(p capnp.Ptr) Chan {
	return Chan(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Chan) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Chan) IsSame(other Chan) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Chan) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Chan) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A Chan_Server is a Chan with a local implementation.
type Chan_Server interface {
	Send(context.Context, Sender_send) error

	Close(context.Context, Closer_close) error

	Recv(context.Context, Recver_recv) error
}

// Chan_NewServer creates a new Server from an implementation of Chan_Server.
func Chan_NewServer(s Chan_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Chan_Methods(nil, s), s, c)
}

// Chan_ServerToClient creates a new Client from an implementation of Chan_Server.
// The caller is responsible for calling Release on the returned Client.
func Chan_ServerToClient(s Chan_Server) Chan {
	return Chan(capnp.NewClient(Chan_NewServer(s)))
}

// Chan_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Chan_Methods(methods []server.Method, s Chan_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 3)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Send(ctx, Sender_send{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Close(ctx, Closer_close{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Recv(ctx, Recver_recv{call})
		},
	})

	return methods
}

// Chan_List is a list of Chan.
type Chan_List = capnp.CapList[Chan]

// NewChan creates a new list of Chan.
func NewChan_List(s *capnp.Segment, sz int32) (Chan_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Chan](l), err
}

type PeekableChan capnp.Client

// PeekableChan_TypeID is the unique identifier for the type PeekableChan.
const PeekableChan_TypeID = 0xb527cbca9bbd8178

func (c PeekableChan) Send(ctx context.Context, params func(Sender_send_Params) error) (stream.StreamResult_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Sender_send_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return stream.StreamResult_Future{Future: ans.Future()}, release
}
func (c PeekableChan) Close(ctx context.Context, params func(Closer_close_Params) error) (Closer_close_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Closer_close_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Closer_close_Results_Future{Future: ans.Future()}, release
}
func (c PeekableChan) Peek(ctx context.Context, params func(Peeker_peek_Params) error) (Peeker_peek_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe95c7f9f41bf520a,
			MethodID:      0,
			InterfaceName: "channel.capnp:Peeker",
			MethodName:    "peek",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Peeker_peek_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Peeker_peek_Results_Future{Future: ans.Future()}, release
}
func (c PeekableChan) Recv(ctx context.Context, params func(Recver_recv_Params) error) (Recver_recv_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Recver_recv_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Recver_recv_Results_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c PeekableChan) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c PeekableChan) AddRef() PeekableChan {
	return PeekableChan(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c PeekableChan) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c PeekableChan) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c PeekableChan) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (PeekableChan) DecodeFromPtr(p capnp.Ptr) PeekableChan {
	return PeekableChan(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c PeekableChan) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c PeekableChan) IsSame(other PeekableChan) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c PeekableChan) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c PeekableChan) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A PeekableChan_Server is a PeekableChan with a local implementation.
type PeekableChan_Server interface {
	Send(context.Context, Sender_send) error

	Close(context.Context, Closer_close) error

	Peek(context.Context, Peeker_peek) error

	Recv(context.Context, Recver_recv) error
}

// PeekableChan_NewServer creates a new Server from an implementation of PeekableChan_Server.
func PeekableChan_NewServer(s PeekableChan_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(PeekableChan_Methods(nil, s), s, c)
}

// PeekableChan_ServerToClient creates a new Client from an implementation of PeekableChan_Server.
// The caller is responsible for calling Release on the returned Client.
func PeekableChan_ServerToClient(s PeekableChan_Server) PeekableChan {
	return PeekableChan(capnp.NewClient(PeekableChan_NewServer(s)))
}

// PeekableChan_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func PeekableChan_Methods(methods []server.Method, s PeekableChan_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 4)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe8bbed1438ea16ee,
			MethodID:      0,
			InterfaceName: "channel.capnp:Sender",
			MethodName:    "send",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Send(ctx, Sender_send{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xfad0e4b80d3779c3,
			MethodID:      0,
			InterfaceName: "channel.capnp:Closer",
			MethodName:    "close",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Close(ctx, Closer_close{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe95c7f9f41bf520a,
			MethodID:      0,
			InterfaceName: "channel.capnp:Peeker",
			MethodName:    "peek",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Peek(ctx, Peeker_peek{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xdf05a90d671c0c07,
			MethodID:      0,
			InterfaceName: "channel.capnp:Recver",
			MethodName:    "recv",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Recv(ctx, Recver_recv{call})
		},
	})

	return methods
}

// PeekableChan_List is a list of PeekableChan.
type PeekableChan_List = capnp.CapList[PeekableChan]

// NewPeekableChan creates a new list of PeekableChan.
func NewPeekableChan_List(s *capnp.Segment, sz int32) (PeekableChan_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[PeekableChan](l), err
}

const schema_872a451f9aa74ebf = "x\xda\x8cU]h#U\x14>'s\xefL\x1b6" +
	"N'\xb7\xaeD\xb6\x06\xa4l`\xc1\xb0\xb6\xe0\xca\xb2" +
	"\xe2\x86 \x01\xa1K\xa6ZP\x08\xc8\x98\xdeZh\x1a" +
	"K\xd2\xd4\xa6P\xa4O*}\xf0\xc5>4*\xb5O" +
	"\xc5\xbcT\xc1\x82\xe0O\x15_lZ\xc1>\x14\xacX" +
	"|\xb1\xd8\x16Z\x11\x04\xa5 \xb3\xdc\x19\xe6'\xcd$" +
	"\xedS\xcb\xe4;\xe7\xfb\xce9\xdf9\xf7v:t\x9f" +
	"<\x1d\xf9K\x81\x90\x9e\xa3\xb2\xd9\x98=}\xee\xa3\xaf" +
	"\xc7\x16@{\x14\x01(*=8x \x85\x11\x90\x1d" +
	"J\xcf\x03\x9a\xfa\xbfc\xfb\x7f\xae\xfc\xb8\x04\xda#\x92" +
	"\xb9\xf9`\xad\x16\x7f\xe1\xd6;\x00\xd0\x83\x8c\x92\x1a\x8b" +
	"\x10\x05\x80u\x13\x85u\x93\x04\xab\x12\xd5\xbc\xd7\xbd\xb1" +
	"\xf3\xdf\xe6\x8b\xb5\x80\x80I\xd2`U+\xa0B\x14V" +
	"!\x09vHT\xf3\xdd'{\xe6\xce\x9f\xb8\xb9nK" +
	" B\xc1>\x09#\x10\xf3\x83\xebw\xc3C\xef\x1f}" +
	"\xe6\x17\xf7=\x89\x0aq[D\x88\xfb\xe4\xdb\x81\xd3\xc5" +
	"\xb3\xe4\x17~\xc0\xb1\x0d\xf8\xdb\x02\xcc.|\xf3ac" +
	";\xb1\x11 F\xa3\xbf\xb2>*\xc4\xc4\xa8\xc2b4" +
	"\xc1\xde\xa3\xaay\xf2\xcf\xdc\xe2z\xeel\xdb\x11\x030" +
	"8O\x1f\x17bNn\xf6G~\x9b\xbfs\xe0\x93\xc9" +
	"\xa9%S\xb9v\xe3\x8d\xc8\xa7\xf4\xf7\x00\x92!Zg" +
	"#\x16\x89N3l\x95*l\x95\xaa\xe6\xd9\xf5\x93g" +
	"{O\xbf:\x0a\x08X\xa2u\xf6\xb1\x15\xb0L3l" +
	"\x8f*l\x8f\xaafxx3\xb5\xf2v\xee8 `" +
	"\x8b\xd6\xd9\xae\x15\xf0\x13\xcd\xb0>Ya}\xb2j>" +
	"8\xee\x9d\xaf\xed\xae\x05\x05hrC\xc0D\xdd\xb2\xc2" +
	"br\x82\xbd*\xab\xe6\x0f\xd5;\x91/\xff\xf8\xf9\xfc" +
	"B\x00\xb2!\xb9\xceF,\xb8.gXU\xfcg\xde" +
	"{\xe5\x99\x9d\xd5_\x94\xff}M2\xe4(B\xce\xcc" +
	"\x8f\x1b\xc5\"/$\xa5\xbc1U\x9c\xba\xfb\x12/\x8e" +
	"\xf2R\xb2\xcc\x8b\xa3\xfdY\xa3dL\x96\x01t\"\x11" +
	"\x00\x82\x00Zd\x00@\xef\x92P\xef\x0da|\xc6(" +
	"T8F\x11\xbd\xf6\x00`\x14\xd0M\x8av\xd2\xf4\xb8" +
	"d\x14\xb3\x88Y\x89\xea]\x88^\xad\xa9.\xf4f\x91" +
	"\xba\x8d\x1a\xc6u\x12\xf2\x01\x004|L'\x88\"\x18" +
	"-.\xd7\xde\xe27\x1b\xee\xa6\xe8\x0cO\x11\xd40\x8a" +
	"/\xbb\xf2B\xb6\xbc,\xe7\x13\xc3<?\xc3K\x00>" +
	"\x95\xee\x08\xdb\xa9t\x01\x01\xb4\xeeN]M\xa5\x0f\xde" +
	"\xa2R\xf2T\xf2Rr\x8a\xf3\x09w2\x171v\x15" +
	"\xc9\x12\xcf\xcf\xf4\x0f\xf3r\xa50\x8d\xe5\xcb\xa7\xe7\x13" +
	"\xd64\xbd\x00\xe2\xab'\xf55\xa7)\xa9\xaf\xe7\xc6\xeb" +
	"\x05\xde\xd1\x1anW\xaeh\x0d\xf7vxMo\x9aC" +
	"{x\xbb\xa6\xa7\x0bo\x96y)\x99\x17\x7f\xec\xe2\xa5" +
	"\xe9r\xa7\xae\xb7L\x06\x1d\x8c*@YD\x9dH\x14" +
	"\xc0=N\xe8\x9cLM\xbb\x05\x90\xba\x86\xa9\x1b\xa8=" +
	"\xa5\xa8\"[\x8bs\x10\x03\xec$>\xde\xc7,bK" +
	"\x11\xe8\xec\xb4*\x96\xda\xe3v\x9e\x10,~\xfe\xdd[" +
	"\x83\xb5\xd7\x96\x1dn\x00-\xa6\xa8b\xf9\x1d\x16w\xb3" +
	"/e\xc9rU\xf8\xc4cq^\x09tn\xfe\x85\x0a" +
	"\x85\xa1ZV\xc9_a\xd3\xc7`\xee\x90w\xb5\xecQ" +
	"5m\xb0+^\x98\xc9\xbd\x97\x1e\x81\xefl\xb5\x98\xc3" +
	"\xe7\xb3v\x15\xa7\x0b\xaa\xa0\xf4*v\xae,:o\x92" +
	"\xa6\x0d@H\xa3J\xdc2\x90UBG\x87Y\xee\xc1" +
	"\xf2\xc3\x00\x00\x00\xff\xffJJ5\xbb"

func init() {
	schemas.Register(schema_872a451f9aa74ebf,
		0x8166bc9c3ded78ca,
		0x95c89fe7d966f751,
		0x9a4abff8ccb5093c,
		0xaf261efa7a102288,
		0xb0e88f4d0a3a1694,
		0xb42eee8bed32bea0,
		0xb527cbca9bbd8178,
		0xcbee5caf8b7af4ea,
		0xdd377ddc0d2426ea,
		0xdf05a90d671c0c07,
		0xe8bbed1438ea16ee,
		0xe95c7f9f41bf520a,
		0xe9a7d19a7d14e94e,
		0xfad0e4b80d3779c3,
		0xfd07d8a1cc36583c)
}
